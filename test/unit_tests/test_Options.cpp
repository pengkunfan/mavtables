// MAVLink router and firewall.
// Copyright (C) 2018  Michael R. Shannon <mrshannon.aerospace@gmail.com>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


#include <stdexcept>

#include "catch.hpp"
#include "fakeit.hpp"

#include "config.hpp"
#include "Filesystem.hpp"
#include "Options.hpp"

#include "common.hpp"


TEST_CASE("'find_config' returns the path to the highest priority "
          "configuration file.", "[Options]")
{
    std::vector<Filesystem::path> paths;
    fakeit::Mock<Filesystem> fs_mock;
    SECTION("First found is given by MAVTABLES_CONFIG_PATH environment "
            "variable.")
    {
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == Filesystem::path("mtbls.conf");
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        auto config_file = find_config(fs_mock.get());
        REQUIRE(config_file.has_value());
        REQUIRE(config_file.value() == "mtbls.conf");
        unsetenv("MAVTABLES_CONFIG_PATH");
        fakeit::Verify(Method(fs_mock, exists)).Exactly(1);
        REQUIRE(paths.size() == 1);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
    }
    SECTION("First found is .mavtablesrc in current directory.")
    {
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == Filesystem::path(".mavtablesrc");
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        auto config_file = find_config(fs_mock.get());
        REQUIRE(config_file.has_value());
        REQUIRE(config_file.value() == ".mavtablesrc");
        unsetenv("MAVTABLES_CONFIG_PATH");
        fakeit::Verify(Method(fs_mock, exists)).Exactly(2);
        REQUIRE(paths.size() == 2);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
    }
    SECTION("First found is .mavtablesrc in HOME directory.")
    {
        Filesystem::path home_path(std::getenv("HOME"));
        home_path /= Filesystem::path(".mavtablesrc");
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == home_path;
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        auto config_file = find_config(fs_mock.get());
        REQUIRE(config_file.has_value());
        REQUIRE(config_file.value() == home_path);
        unsetenv("MAVTABLES_CONFIG_PATH");
        fakeit::Verify(Method(fs_mock, exists)).Exactly(3);
        REQUIRE(paths.size() == 3);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[2] == Filesystem::path(home_path));
    }
    SECTION("First found is PREFIX/etc/mavtables.conf.")
    {
        Filesystem::path home_path(std::getenv("HOME"));
        home_path /= Filesystem::path(".mavtablesrc");
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == (PREFIX "/etc/mavtables.conf");
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        auto config_file = find_config(fs_mock.get());
        REQUIRE(config_file.has_value());
        REQUIRE(config_file.value() == (PREFIX "/etc/mavtables.conf"));
        unsetenv("MAVTABLES_CONFIG_PATH");
        fakeit::Verify(Method(fs_mock, exists)).Exactly(4);
        REQUIRE(paths.size() == 4);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[2] == Filesystem::path(home_path));
        REQUIRE(paths[3] == Filesystem::path(PREFIX "/etc/mavtables.conf"));
    }
    SECTION("Failed to find any configuration file.")
    {
        Filesystem::path home_path(std::getenv("HOME"));
        home_path /= Filesystem::path(".mavtablesrc");
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return false;
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        auto config_file = find_config(fs_mock.get());
        REQUIRE_FALSE(config_file.has_value());
        unsetenv("MAVTABLES_CONFIG_PATH");
        fakeit::Verify(Method(fs_mock, exists)).Exactly(4);
        REQUIRE(paths.size() == 4);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[2] == Filesystem::path(home_path));
        REQUIRE(paths[3] == Filesystem::path(PREFIX "/etc/mavtables.conf"));
    }
}


TEST_CASE("Options's class prints the help message.", "[Options]")
{
    MockCOut mock_cout;
    std::string help_message =
        "usage: <program name here>:\n"
        "  -h [ --help ]         print this message\n"
        "  --config arg          specify configuration file\n"
        "  --ast                 print AST of configuration file (do not run)\n"
        "  --version             print version and license information\n"
        "  --loglevel arg        level of logging, between 0 and 3\n\n";
    SECTION("When given the '-h' flag.")
    {
        int argc = 2;
        const char *argv[2] = {"<program name here>", "-h"};
        Options options(argc, argv);
        REQUIRE(mock_cout.buffer() == help_message);
        REQUIRE_FALSE(options);
    }
    SECTION("When given the '--help' flag.")
    {
        int argc = 2;
        const char *argv[2] = {"<program name here>", "--help"};
        Options options(argc, argv);
        REQUIRE(mock_cout.buffer() == help_message);
        REQUIRE_FALSE(options);
    }
}


TEST_CASE("Options's class prints version information when given the "
          "'--version' flag.", "[Options]")
{
    MockCOut mock_cout;
    int argc = 2;
    const char *argv[2] = {"<program name here>", "--version"};
    Options options(argc, argv);
    REQUIRE(
        mock_cout.buffer() ==
        "mavtables (SHAMU Project) v" + std::to_string(VERSION_MAJOR) +
        "." + std::to_string(VERSION_MINOR) +
        "." + std::to_string(VERSION_PATCH) +
        "\nCopyright (C) 2018  Michael R. Shannon\n"
        "\n"
        "License: GPL v2.0 or any later version.\n"
        "This is free software; see the source for copying conditions.  "
        "There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A "
        "PARTICULAR PURPOSE.\n");
    REQUIRE_FALSE(options);
}


TEST_CASE("Options's class will use the given configuration file "
          "(--config flag).", "[Options]")
{
    MockCOut mock_cout;
    std::vector<Filesystem::path> paths;
    fakeit::Mock<Filesystem> fs_mock;
    SECTION("File found.")
    {
        // Setup mocks.
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == Filesystem::path("examples/test.conf");
        });
        // Construct Options object.
        int argc = 3;
        const char *argv[3] = {"mavtables", "--config", "examples/test.conf"};
        Options options(argc, argv, fs_mock.get());
        // Verify Options object.
        REQUIRE(options.config_file() == "examples/test.conf");
        REQUIRE(options);
        REQUIRE_FALSE(options.ast());
        REQUIRE(options.run());
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(1);
        REQUIRE(paths.size() == 1);
        REQUIRE(paths[0] == Filesystem::path("examples/test.conf"));
    }
    SECTION("File not found (throws error).")
    {
        // Setup mocks.
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return false;
        });
        // Construct Options object.
        int argc = 3;
        const char *argv[3] =
        {
            "mavtables", "--config", "non_existant_file.conf"
        };
        // Verify Options object.
        REQUIRE_THROWS_AS(
            Options(argc, argv, fs_mock.get()), std::runtime_error);
        REQUIRE_THROWS_WITH(
            Options(argc, argv, fs_mock.get()),
            "mavtables could not locate a configuration file");
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(2);
        REQUIRE(paths.size() == 2);
        REQUIRE(paths[0] == Filesystem::path("non_existant_file.conf"));
        REQUIRE(paths[1] == Filesystem::path("non_existant_file.conf"));
    }
}


TEST_CASE("Options's class finds the configuration file.", "[Options]")
{
    MockCOut mock_cout;
    std::vector<Filesystem::path> paths;
    fakeit::Mock<Filesystem> fs_mock;
    SECTION("First found is given by MAVTABLES_CONFIG_PATH environment "
            "variable.")
    {
        // Setup mocks.
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == Filesystem::path("mtbls.conf");
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        // Construct Options object.
        int argc = 1;
        const char *argv[2] = {"mavtables"};
        Options options(argc, argv, fs_mock.get());
        unsetenv("MAVTABLES_CONFIG_PATH");
        // Verify Options object.
        REQUIRE(options.config_file() == "mtbls.conf");
        REQUIRE(options);
        REQUIRE_FALSE(options.ast());
        REQUIRE(options.run());
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(1);
        REQUIRE(paths.size() == 1);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
    }
    SECTION("First found is .mavtablesrc in current directory.")
    {
        // Setup mocks.
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == Filesystem::path(".mavtablesrc");
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        // Construct Options object.
        int argc = 1;
        const char *argv[2] = {"mavtables"};
        Options options(argc, argv, fs_mock.get());
        unsetenv("MAVTABLES_CONFIG_PATH");
        // Verify Options object.
        REQUIRE(options.config_file() == ".mavtablesrc");
        REQUIRE(options);
        REQUIRE_FALSE(options.ast());
        REQUIRE(options.run());
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(2);
        REQUIRE(paths.size() == 2);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
    }
    SECTION("First found is .mavtablesrc in HOME directory.")
    {
        // Setup mocks.
        Filesystem::path home_path(std::getenv("HOME"));
        home_path /= Filesystem::path(".mavtablesrc");
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == home_path;
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        // Construct Options object.
        int argc = 1;
        const char *argv[2] = {"mavtables"};
        Options options(argc, argv, fs_mock.get());
        unsetenv("MAVTABLES_CONFIG_PATH");
        // Verify Options object.
        REQUIRE(options.config_file() == home_path);
        REQUIRE(options);
        REQUIRE_FALSE(options.ast());
        REQUIRE(options.run());
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(3);
        REQUIRE(paths.size() == 3);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[2] == Filesystem::path(home_path));
    }
    SECTION("First found is PREFIX/etc/mavtables.conf.")
    {
        // Setup mocks.
        Filesystem::path home_path(std::getenv("HOME"));
        home_path /= Filesystem::path(".mavtablesrc");
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return p == (PREFIX "/etc/mavtables.conf");
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        // Construct Options object.
        int argc = 1;
        const char *argv[2] = {"mavtables"};
        Options options(argc, argv, fs_mock.get());
        unsetenv("MAVTABLES_CONFIG_PATH");
        // Verify Options object.
        REQUIRE(options.config_file() == (PREFIX "/etc/mavtables.conf"));
        REQUIRE(options);
        REQUIRE_FALSE(options.ast());
        REQUIRE(options.run());
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(4);
        REQUIRE(paths.size() == 4);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[2] == Filesystem::path(home_path));
        REQUIRE(paths[3] == Filesystem::path(PREFIX "/etc/mavtables.conf"));
    }
    SECTION("Failed to find any configuration file.")
    {
        // Setup mocks.
        Filesystem::path home_path(std::getenv("HOME"));
        home_path /= Filesystem::path(".mavtablesrc");
        fakeit::When(Method(fs_mock, exists)).AlwaysDo([&](auto p)
        {
            paths.push_back(p);
            return false;
        });
        setenv("MAVTABLES_CONFIG_PATH", "mtbls.conf", true);
        // Construct Options object.
        int argc = 1;
        const char *argv[2] = {"mavtables"};
        REQUIRE_THROWS_AS(
            Options(argc, argv, fs_mock.get()),
            std::runtime_error);
        REQUIRE_THROWS_WITH(
            Options(argc, argv, fs_mock.get()),
            "mavtables could not locate a configuration file");
        unsetenv("MAVTABLES_CONFIG_PATH");
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
        // Verify exists calls.
        fakeit::Verify(Method(fs_mock, exists)).Exactly(8);
        REQUIRE(paths.size() == 8);
        REQUIRE(paths[0] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[1] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[2] == Filesystem::path(home_path));
        REQUIRE(paths[3] == Filesystem::path(PREFIX "/etc/mavtables.conf"));
        REQUIRE(paths[4] == Filesystem::path("mtbls.conf"));
        REQUIRE(paths[5] == Filesystem::path(".mavtablesrc"));
        REQUIRE(paths[6] == Filesystem::path(home_path));
        REQUIRE(paths[7] == Filesystem::path(PREFIX "/etc/mavtables.conf"));
    }
}


TEST_CASE("Options's class sets run to false and ast to true when the --ast "
          "flag is given.", "[Options]")
{
    MockCOut mock_cout;
    // Setup mocks.
    fakeit::Mock<Filesystem> fs_mock;
    fakeit::When(Method(fs_mock, exists)).AlwaysReturn(true);
    // Construct Options object.
    int argc = 4;
    const char *argv[4] =
    {
        "mavtables", "--ast", "--config", "test/mavtables.conf"
    };
    Options options(argc, argv);
    // Verify Options object.
    REQUIRE(options.config_file() == "test/mavtables.conf");
    REQUIRE(options);
    REQUIRE(options.ast());
    REQUIRE_FALSE(options.run());
    // Verify printing.
    REQUIRE(mock_cout.buffer().empty());
}


TEST_CASE("Option's class has a loglevel option", "[Options]")
{
    MockCOut mock_cout;
    // Setup mocks.
    fakeit::Mock<Filesystem> fs_mock;
    fakeit::When(Method(fs_mock, exists)).AlwaysReturn(true);
    SECTION("defaults to loglevel 0")
    {
        // Construct Options object.
        int argc = 3;
        const char *argv[3] = {"mavtables", "--config", "test/mavtables.conf"};
        Options options(argc, argv);
        // Verify Options object.
        REQUIRE(options.loglevel() == 0);
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
    }
    SECTION("sets the loglevel when the --loglevel is given")
    {
        // Construct Options object.
        int argc = 5;
        const char *argv[5] =
        {
            "mavtables", "--loglevel", "3", "--config", "test/mavtables.conf"
        };
        Options options(argc, argv);
        // Verify Options object.
        REQUIRE(options.loglevel() == 3);
        // Verify printing.
        REQUIRE(mock_cout.buffer().empty());
    }
}
